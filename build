#!/usr/bin/env python

# build - turn pydink game into old-style dmod.
# Copyright 2011 Bas Wijnen
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import dink
import os

created = False
def check (f, content = None):
	global created
	if not os.path.exists (f):
		created = True
		if content == None:
			os.mkdir (f)
			print 'Created directory %s\n' % f
		else:
			open (f, 'w').write (content)
			print 'Created file %s\n' % f

assert len (sys.argv) == 2
root = sys.argv[1]
base = os.path.basename (root)
if base == '':
	base = os.path.basename (os.path.dirname (root))

check (root)
check (os.path.join (root, 'world'))
check (os.path.join (root, 'script'))
check (os.path.join (root, 'info' + os.extsep + 'txt'), '%s\n\nThis file should claim copyright and describe the dmod.' % base)
title = os.path.join (root, 'title' + os.extsep + 'txt')
check (title, '''\
start = 400 300 200
#music = titlemusic
sprites = 0
#sprite-1 = logo 1		0 0
#color = 0
#background = background
buttons = 4
button-1 = button-start 1	76 40	game-start
button-2 = button-continue 1	524 40	game-continue
button-3 = button-quit 1	560 440	game-quit
button-4 = button-ordering 1	104 440	game-credits
#title-script = custom-title
#start-script = custom-start
pointer = special 8
''')
#check (os.path.join (root, os.path.join ('seq', 'info' + os.extsep + 'txt')), '''\
#collection = walk
#append = name_of_defined_sequence
#name = name_of_sequence
#direction = direction_for_collection
#box = x y left top right bottom
#delay = 33
#box-2 = x y left top right bottom
#delay-3 = 50
#frames = 3
#repeat = yes
#special = 1
#load-now = no
#code = 900
#preload = sequence
#type = normal
#''')
sprite_scripts = []
button_scripts = []
other_scripts = []
for l in open (title).readlines ():
	w = l.split ('=', 1)
	if len (w) != 2:
		continue
	if w[0].strip () in ('start-script', 'title-script'):
		other_scripts += (w[1].strip (),)
		continue
	if not w[0].strip ().startswith ('button-') and not w[0].strip ().startswith ('sprite-'):
		continue
	if w[0].strip ().startswith ('button-'):
		w = w[1].split ()
		if len (w) >= 5:
			button_scripts += (w[4],)
	else:
		w = w[1].split ()
		if len (w) >= 6:
			sprite_scripts += (w[5],)
r = os.path.join (root, 'world')
for rn in os.listdir (r):
	rf = os.path.join (r, rn)
	if not os.path.isdir (rf):
		other_scripts += [x.split ('=', 1)[1].strip () for x in open (rf).readlines () if x.strip ().startswith ('script')]
	rfs = rf + '-sprite'
	if os.path.isdir (rfs):
		for s in os.listdir (rfs):
			sf = os.path.join (rfs, s)
			sprite_scripts += [x.split ('=', 1)[1].strip () for x in open (sf).readlines () if x.strip ().startswith ('script')]
button_click = '''\
	spawn ("start-game");
	kill_this_task ();
'''
#for s in button_scripts:
#	check (os.path.join (os.path.join (root, 'script'), s + os.extsep + 'c'), '''\
#void main ()
#{
#}
#
#void buttonon ()
#{
#	sp_pframe (current_sprite, 2);
#}
#
#void buttonoff ()
#{
#	sp_pframe (current_sprite, 1);
#}
#
#void click ()
#{
#''' + button_click + '''\
#}
#''')
#	button_click = '	// TODO\n'
#for s in sprite_scripts:
#	if s in button_scripts:
#		continue
#	check (os.path.join (os.path.join (root, 'script'), s + os.extsep + 'c'), '''\
#// TODO
#void main ()
#{
#}
#
#void talk ()
#{
#}
#
#void touch ()
#{
#}
#
#void hit ()
#{
#}
#''')
#for s in other_scripts:
#	if s in sprite_scripts:
#		continue
#	if s == 'escape':
#		script_main = 'kill_game ();\n'
#	else:
#		script_main = '// TODO\n'
#	check (os.path.join (os.path.join (root, 'script'), s + os.extsep + 'c'), '''\
#void main ()
#{
#''' + script_main + '''\
#}
#''')
if created:
	room = os.path.join (os.path.join (root, 'world'), '400-15-12.txt')
	check (room, '''\
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2 4,2,2
#hard = alternate-hardness-map
#music = midi-name
#script = run-when-entered
#indoor = no
''')
	print 'Content created: not running build.'
	sys.exit (0)

def rmr (path):
	for f in os.listdir (path):
		fullpath = os.path.join (path, f)
		if os.path.isdir (fullpath):
			rmr (fullpath)
		else:
			os.remove (fullpath)
	os.rmdir (path)

data = dink.Dink (root)
home = os.path.expanduser ('~')
dmods = os.path.join (home, 'dmods')
if not os.path.exists (dmods):
	os.mkdir (dmods)
dmod = os.path.join (dmods, base)
if os.path.exists (dmod):
	rmr (dmod)

data.build (dmod)
